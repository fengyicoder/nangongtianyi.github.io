---
title: Programmer and Mathematics (一)
date: 2021-01-09 13:24:25
categories:
    - 文章
mathjax: true
---

# 多项式

从加密开始，假设现在有一条秘密消息，将其分成10个部分进行编码，接收方只要知道任意6个部分，就可以重建消息，但如果少于6个部分，甚至不能确定原始消息的一小段，要实现这种方案，多项式足以。

<!-- more -->

**定义2.1：**实系数单变量多项式是输入为实数输出也为实数的一种函数，形式如下：
$$
f(x) = {a_0} + {a_1}x + {a_2}{x^2} + ... + {a_n}{x^n}
$$
其中${a_i}$是$f(x)$的系数，且必须是非负整数，多项式的次数为$n$。

从程序语言来讲，一个关于系数的数组就可以限定一个多项式，例如a[i]就代表${a_i}$，数组的长度就代表多项式的次数。

多项式是非常重要的，其内部的乘加特性，可以延申到所有的算数运算。现在暂时扩展到多变量，在程序语言中的与或非，就是非常简单的多变量多项式，但最终能产生全部的算法范围。

考虑一种特殊情况，虽然次数存在，但系数全部为0。在这种情况下，虽然是合理的但次数就失去了其应有的意义，因此，“按惯例”，最后一个系数${a_n}$应该是非零的，同时，特别定义$f(x) = 0$是零多项式，其次数为-1。

当定义一个函数的时候通常使用如下的表示：$f:A \to B$。所有可能的输入被称作域，所有可能的输出被称作范围。在数学中，范围是所有真实输出的集合，输出的类型称为共域。在上述的表达中，我们指定$A$代表域，$B$代表共域。

了解了一些基本的概念之后，可以着手实现前文所述的加密，这里需要利用到以下的定理：经过给定点集的多项式的存在性与唯一性定理。

**定义2.2：**对任意整数$n \ge 0$和属于$\mathbb{R}^{2}$的$n+1$个点的点集$({x_0},{y_0}),({x_1},{y_1}),...,({x_n},{y_n})$，其中${x_0} < {x_1} < {x_2} < ... < {x_n}$，存在一个唯一的$n$次多项式，使得对所有的$i$有$p({x_i}) = {y_i}$。

其中，$\mathbb{R}^{2}$代表了一对实数，每个实数都属于$\mathbb{R}$，类似的，$\mathbb{Z}^{3}$代表一个整数的三元组。

这个定理可以用一种更简短的方式陈述：存在唯一的$n$次多项式，其经过了$n+1$个点的选择。当看见一个新定理的时候，要做的第一件事就是写下一个最简单的例子，这样除了能够简化定理，还能够提供示例，为审阅证明定理的时候使用。例如对以上的定理选择$(7,4)$这个例子，这是一个零次多项式，函数唯一且确定，为$f(x)=4$。接下来稍微复杂一点，考虑数据为$(2,3),(7,4)$，这是一个一次多项式，也能很容易的确定这个多项式应为$f(x) = \frac{{13}}{5} + \frac{1}{5}x$。在几何上，次数为1的多项式是一条直线。这是显而易见的，在两点之间有唯一的一条直线。此外，定理还指出了${x_0} < {x_1} < {x_2} < ... < {x_n}$，那么来考虑下${x_0} = {x_1}$的情况，例如$(2,3),(2,5)$。

我们不考虑真实答案，只猜测可能没有次数为1的多项式经过这两点，或者有多个次数为1的多项式经过这两点，那么就破坏了唯一性。因此，我们应该尝试以一种更加精确的方式阅读定义。

现在考虑证明2.2，将包括两个部分，存在性和唯一性。首先，我们将证明存在一个满足要求的多项式，然后证明如果两个多项式都满足要求，则它们必须相同。下面将通过直接构造的方式来证明存在性。与前文类似，我们还是从最简单的方式开始，但是是以一种通用的形式。此时如果是一个点$(x_1, y_1)$，则多项式为$f(x) = {y_1}$，两个点的情况我们直接写成以下的形式$f(x) = {y_1}\frac{{x - {x_2}}}{{{x_1} - {x_2}}} + {y_2}\frac{{x - {x_1}}}{{{x_2} - {x_1}}}$，显然，满足要求，且式中已经包含了${x_1} \ne {x_2}$。将其简化为多项式的标准形式：
$$
f(x) = \frac{{{x_1}{y_2} - {x_2}{y_1}}}{{{x_1} - {x_2}}} + (\frac{{{y_1} - {y_2}}}{{{x_1} - {x_2}}})x
$$
显然，$x$的幂没有出现大于1的情况，而且没有出现两个$x$相乘的情况，那么，可以确信此多项式的次数为1.

三个点的多项式，我们也可以按照以上的方式进行构造：
$$
f(x) = {y_1}\frac{{(x - {x_2})(x - {x_3})}}{{({x_1} - {x_2})({x_1} - {x_3})}} + {y_2}\frac{{(x - {x_1})(x - {x_3})}}{{({x_2} - {x_1})({x_2} - {x_3})}} + {y_3}\frac{{(x - {x_1})(x - {x_2})}}{{({x_3} - {x_1})({x_3} - {x_2})}}
$$
同理，$n+1$个点的多项式就很容易构造了，如下：
$$
f(x) = \sum\limits_{i = 0}^n {{y_i}(\prod\limits_{j \ne i} {\frac{{x - {x_j}}}{{{x_i} - {x_j}}}} )} 
$$
此时，其实已然证明了存在性，因为每一项都是$n$次的，这显然是一个$n$次的多项式。

下面展示以下上式中某些数学符号的代码展示，有以下的例子：
$$
f(x) = \sum\limits_{i = 0}^n {bar(i)(\prod\limits_{j \ne i} {foo(i,j)} )} 
$$

```c++
int i, j;
sometype theSum = defaultSumValue;
for (i = 0; i <= n; i++) {
	othertype product = defaultProductValue;
	for (j = 0; j <= n; j++) {
		if (j != i) {
			product *= foo(i, j);
		}
	}
	theSum += bar(i) * product;
}
return theSum;
```

