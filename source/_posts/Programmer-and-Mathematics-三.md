---
title: "\x96Programmer-and-Mathematics-三"
date: 2021-02-16 21:31:25
tags:
categories:
    - 文章
mathjax: true
---



# 变量名、重载和你的大脑

开发人员经常抱怨数学家们如何使用单字母的名称，如何重载和滥用符号，以及他们用来形容事物的单词本质上是无意义的，其唯一目的就是创造一个新单词。但是，开发人员却很少思考这背后的原因。

<!-- more -->

主要的原因是文化。在创造数学时，数学家有两个目标：发现关于数学事物的见解，然后以直观优雅的方式将真理传达给他人。尽管第二个目标暗示了数学家们确实有自己的风格，但使得证明或者数学理论更为优雅的首要目标还是希望其有助于理解。

在开发人员的眼中，好的软件是可维护的，可扩展的，模块化，可测试的，健壮的等等，但数学家们不会关心这些，因为数学不是生意。数学不是傻瓜式的证明，数学理论的成功并不依赖下一个傻瓜是否理解它。

数学不是被设计成可以扩展到数百万的普通人身上，而是要在抽象的基础上更进一步。从字面上来讲，纸上的标记促进了人类从勉强能做的算数到今天的机器学习算法和密码协议。到19世纪末才发明的集合使数学的抽象更进了一步。之后范畴论更是在抽象的层面上前进了一大步。

这样做的结果就是数学家们优化了他们的论述，能够最大限度提高效率和最小化认知负荷。

**变量名。**变量名旨在传递一些信息：类型、行为、起源等。每个数学家都知道$n$是自然数$f$是函数。数学家的每个领域都有他们的小约定来帮助节省时间，因为数学家们的交流通常是实时的（例如通过一块黑板）。当写下${f^*}$意味着是一种规范同构，而不必写成InducedHomomorphismF。

更深入的讲，通常更长的名字并不能更深入的阐明数学对象的性质。难道${f^*}$真的比InducedF所表示的含义更少吗？通常来说，越抽象，这些命名的约定越容易设计。$L$跟${\text{L}}$可以是不同的东西，前者代表对象，后者可能是一个函数，这是通过字体来区分。

归根到底，数学家对变量的命名是经过长期历史的沉淀的一种约定俗成。

**操作符重载。**重载的一个关键功能是突出了操作的预期性质。数学家们经常使用等式不等式以及类似$ \cong $这样的符号来代表一些我们不关心的差异。理想情况下，我们应该能从上下文来推断运算的含义。简而言之，就是我们的代码要写的规范。

**Sloppy notation。**总结下，有些符号例如求和符号虽然代码表示比较麻烦，但数学上非常简洁。

# 图

## 图的定义

图的定义从图示看更为的直观，如图6.1所示，所谓的图就是有一堆事物以及他们的连接关系所组成的。举个简单的例子，事物现在就是机场，如果机场之间有航线的话它们就被连接在一起。我们使用点和线来来描述这种结构，我们所关心的就是这种连接的结构。

![](/img/6.1.png)

现在我们使用建模的语言来描述这个定义。事物我们称作顶点（或者节点），连接关系称作边（或者线？）。为了简化定义，我们沿用第四章的定义，从集合中取出两个事物：
$$
\left( {\begin{array}{*{20}{c} }
  V \\ 
  2 
\end{array} } \right) = \{ \{ {v_1},{v_2}\} :{v_1} \in V,{v_2} \in V,{v_1} \ne {v_2}\} 
$$
**定义6.1：**图包含了节点$V$的集合，边的集合$E \subset \left( {\begin{array}{*{20}{c} }
  V \\ 
  2 
\end{array} } \right)$。整个的图可以被表示为$G = (V,E)$。

或者，可以将$E$视为任意集合，但存在这样一个函数$f:E \to \left( {\begin{array}{*{20} {c} }
  V \\ 
  2 
\end{array} } \right)$来描述这一条边连接着哪对点。一般来讲，数学家们会直接将边写成$e = (u,v)$。

以下是一些图的术语。我们一般将节点的数目称作$n=|V|$，边的数目称作$m=|E|$，对我们来说，这些值总是有限的。当两个节点$u,v \in V$被边$e=(u,v)$连接时，我们称这两个节点相邻接，$e$关联到$u$和$v$。$v$是$u$的邻接点，并将$N(u)$定义为$u$的邻接点的集合：
$$
N(u) = \{ v \in V:(u,v) \in E\} 
$$
邻接点（也就是入射边的数目）的数目称作顶点的度，将顶点映射到其度的函数称作deg：$V \to \mathbb{Z}$。为了更好的理解这些术语，可以看一下图6.2。

![](\img\m6.2.png)

其中$v$代表顶点，$e$代表边。$v_1$和$v_3$是邻接点，$e_2$关联$v_1$，$deg(v_2)=3$，$v_2$的所有邻接点也是$v_3$的邻接点。

本章中我们需要的另一个概念是连通图。首先，图中的“路径”指的是顶点与边交替的序列$({v_1},{e_1},{v_2},{e_2}, \ldots ,{v_t})$，其中每条边${e_i} = ({v_i},{v_{i + 1}})$都连接着相邻的顶点。从视觉上看，路径其实就是沿着边从一个顶点到另一个顶点遍历$G$的一种方式。在图6.2中，从$v_2$到$v_4$有许多不同的路径，有四条不重复任何顶点。很多作者都将路径限定为不经过重复的顶点，对于重复顶点的路径叫做途径和迹。

如果存在路径能够从任意一个顶点到达另一个顶点，这样的图称为连通，否则称为不连通。等效的，如果不能将$V$分成两个子集$X$和$Y$，且两者没有没有边连接，则这样的图是连通的。非连通的图是一些连通组件的并集，这里我们说的组件$v$指的是包含$v$的连通子图。一个顶点也可以是连通组件，这样的点称为孤立点。

## 图形着色

本章的研究内容是图$G=(V,E)$的上色问题，即对图中顶点颜色的分配使其满足某种属性。

**定义6.2：**$G=(V,E)$上的$k$色是这样一个函数：$\varphi :V \to \{ 1,2, \ldots ,k\} $，当$\varphi (u) \ne \varphi (v)$时我们称$e=(u,v)$着色正确，否则边着色不正确。如果每条边都着色正确则$\varphi $正确。如果图$G$有正确的$k$色，则着色完成。

现在在继续之前，写下较小的$n$和$k$作为例子。因为这是一个至关重要的定义，所以例子稍稍有些复杂。Petersen图如6.3所示，这种图在图论中具有十分重要的地位，因为它是最小的严格单元测试。错误的猜想往往会在Petersen图中失败，petersen图是三色的而不是两色的。

![](\img\m6.3.png)

**定义6.3：**图$G$的图色数用$\chi (G)$来表示，是当$G$是$k$色时最小的那个$k$。

通过以上的解释，Petersen图的图色数为3。

**定义6.4：**如果$G=(V,E)$是图，$d$是一个顶点$v \in V$的最大的度，则有$\chi (G) \leqslant d + 1$。

**证明：**这里使用贪婪策略来对图进行着色，以任意顺序选择$G$中顶点${v_1}, \ldots {v_n}$，对每一个$v_i$都挑选一个其邻接点未使用过的颜色$j$。在最坏的情况下，一个的度为$d$顶点$v$，其邻接点全部使用不同的颜色，则会使用$d+1$种颜色，否则其邻接点会重用某种颜色，所以在最坏的情况下颜色的数目是图中最大的度加上1。

关于思考图进行着色的另一个角度是分区。特别的，如果$G=(V,E)$是图，$\varphi $是着色函数，我们要找的是${\varphi ^{ - 1} }(j)$，即颜色为$j$的顶点的集合。很显然，符合条件的顶点之间没有边相接。而且，由于$\varphi $是一个函数，则${\varphi ^{ - 1} }(j)$将集合分成了不同的颜色类别，所有的边都连接着不同类别，如图6.5所示。

![](\img\m6.5.png)

这个角度是非常重要的，因为人们可以尝试从不正确的或未完成的着色开始完成正确的着色，并用其纠正不正确的着色。我们将在本章的实践（平面图着色）来进行实操，现在我们来思考图的着色为什么有用。

## 寄存器分配和难度

促进图着色发展的一种原因是可以将许多问题表达为“反协调问题”，即描述为当系统中代理人与其邻居没有相同行为时，将获得胜利。一个具体的例子就是射频，无线电发射塔选择某种要发射的频率，当附近的发射塔发射相同的频率时会相互干扰，因此，发射塔是顶点，附近的发射塔与其通过边相连接，这个问题中“颜色”就是频率。

一个有趣又令人满意的实践是寄存器分配。也就是说，假设你正在为某种编程语言写一个编译器。逻辑上讲，开发者对程序中变量的数量没有限制，但在物理机上，只有固定数量的寄存器来存储这些变量。现在与图着色的联系开始显现出来，顶点是逻辑变量，对应的颜色是物理寄存器，现在还未讨论顶点如何用边进行连接。直观上，这取决于逻辑变量在其使用范围内是否“重叠”（下面会通过例子进行解释）。范围重叠的这种结构注定要用图论进行研究。

为了简化这个事情，我们将会做一些编译器设计者会做的行为，然后将一个程序几乎完全编译成汇编代码，这当中唯一的区别是我们允许有无限个虚拟寄存器，我们称它们为变量。因此对一个特定的程序$P$，我们使用$np \in \mathbb{N}$来表示程序中使用不同变量的数量，每一个变量都是$G$中的顶点。

举一个例子进行说明，假设已编译好的程序如下，其中$符号代表变量：

![](\img\6.2.png)

在本例中41和42不能共享寄存器，它们有不同的值且在同一行用来计算差值（个人理解是因为这两个变量同时使用了，所以分属不同的寄存器）。如果之后有代码使用了某个变量的值，直接调用即可。换个角度来看：对于一个变量，在上次读取和下次写入之间，这个变量在寄存器中都是无效的。每当有变量失效，那么重用其寄存器是安全的（无效变量的值存储在内存中）。

现在我们可以定义边了。如果在程序中两个变量同时活跃（可以理解成同时使用），那么这两个变量\$i和\$j同时相互"干涉"，因此我们将边$(i,j)$添加到$G$中。通过一些工作（巧合的使用图来进行流量分析），可以有效的计算代码中每个变量存在的位置并构造图$G$，之后我们可以计算该图的图色数并找到一个实际的值$\chi (G)$进行着色。无需进行更深入的理论研究，以上的方法就能最有效的利用我们的物理寄存器。

不幸的是，你不应该总是寄希望于能计算任意图的图色数。这个难题就是所谓的“NP-hard”，这意味着我们找不到任何正确的方法能够比暴力搜索所有可能的颜色更快，我们不能希望能够很快的找到答案。

而且，甚至获取一个一般图的图色数的近似值都是一个NP-hard。更具体的来说，我们不寄希望能够找到这样一种算法：给定一个图$G$和$n$个顶点，对任意$0<c<1$，我们可以得到使得$\frac{Z} { {\chi (G)} } < {n^c}$的一个$Z$。这是一种渐近的描述方式，意味着一个有希望的算法（可能存在这样的算法）可能会证明适用于所有顶点小于1000的图，对于某些问题，这可能已经足够了。但现在以一个例子来稍微解释一下这个理论，假定顶点数目为$n = {10^5}$的图，取$c=0.5$，算法很难求出一个数字保证在$\chi (G)$和$100 * \chi (G)$之间。这个乘数因子随着图的大小呈现多项式的增长。

但是此处离题了。结论就是着色是一个难题，对于确实想要为图着色的人来说这可能是悲哀的。但是还有其他的方法可以解决此问题，你可以假设你的图有着不错的结构，这是下一节将会讨论的问题，那么实际上图色数最多为4。你也可以假设你知道图色数，尝试在边正确（即两端的顶点颜色不同）的前提下进行着色。我们会在以后见到这个方法。

## 平面图和欧拉示性数

我们对图施加一个条件使得图的着色更加容易，这个条件就是平面图。如果图$G=(V,E)$可以以边相互不相交的方式绘制在平面上，那么这个图就是平面图，如图6.3所示：

![](\img\6.3.png)

这个给出一个练习：想出一个非平面图的例子并尝试证明。有时候你画不出来并不代表它不是。

图6.4画出了两个非平面图的重要例子，左边那个有5个顶点的图称作完全图，用$K_5$来表示，这里的完全代表顶点之间所有可能的边都存在。第二个图称为完全二分图$K_{3,3}$，二分代表有两部分，完全指的是两部分之间存在所有可能的边。${K_{a,b} }$的下标$a,b \in \mathbb{N}$代表一部分有$a$个顶点，一部分有$b$个顶点。

![](\img\6.4.png)

我们使用在平面上绘制这种术语非正式的定义平面图。该平面图不适用集合、函数或者任何你期望的东西。实际上，这个定义确实只属于你的大脑，平面图的正式的定义是嵌入到${\mathbb{R}^2}$。问题在于嵌入这个概念定义需要很多乱七八糟的东西，因为其适用空间比图更广。

平面图的一个特性是当你以边不相交的方式绘制平面图时，你会将${\mathbb{R}^2}$分成不同的face。图6.5就展示了一个拥有4个face的平面图，因为我将图形的外面也称作一个face。如果我以$f$作为face的数目，$n$作为顶点的数目，$m$是边的数目，然后我们可以注意到$n - m + f = 2$，

![](\img\6.5.png)

令人惊讶的事实是，这个等式并不取决于你怎么画这个图，只要你画的图没有交叉的边，那么这个等式总会成立，我们会简单的证明它。

**定理6.5：**对任意连接的平面图$G = (V,E)$，和其在${\mathbb{R}^2}$绘制的任何方式，定义face的集合$F$，有$|V| - |E| + |F| = 2$。

**证明：**我们对顶点和边的数量进行归纳。最基础的情况是只有一个顶点，则$|V| = 1,|E| = 0,|F| = 1$，成立。

现在假设我们有一个定理成立的图$G$，我们会使图更大并展示此定理仍成立。特别的是，我们对$|V| + |E|$的数量进行归纳。有两种情况：要么在两个已存在的顶点之间添加一条边，要么我们添加一条边与一个新的顶点（现在度为1）相连。

在第一种情况下，$|V|$未改变，$|E|$增加1，$|F|$也增加1，因为新边将face一分为二，所以有：
$$
|V| - (|E| + 1) + (|F| + 1) = |V| - |E| + |F| = 2
$$
请注意只要不与其他边相交，我们就可以创建一个以上的face，如何绘制边无关紧要。第二种情况相似，只是现在不会创建新的face。说服你自己，包围一个face的路径的任意顶点的度都至少为2。所以我们的新图$|V| + 1 - (|E| + 1) + |F| = 2$。归纳完成。

这是一个令人惊讶的事实，我们从图的绘制中得到一些度量值，但这些度量值却不取决于绘制图的选择，这称为invariant，我们会在以后的章节中讨论。注意，图连接方式的要求对定理的成立至关重要，因为当一个图有$n$个顶点却没有边的时候，有$|V| - |E| + |F| = n + 1$。

## 实践：五色定理

对于平面图来说，存在这样令人惊奇的定理。

**定理6.6：**（四色定理）每个平面图都可以用四种颜色上色。

这个证明漫长且困难，还有下面一个容易证明的定理。

**定理6.7：**（五色定理）每个平面图都可以被五种颜色上色。

如果个人经常犯错误的话，那么五色定理与四色定理差不多，证明需要几个引理。

**引理6.8：**如果$G$是一个图，有$m$条边，那么$2m = \sum\nolimits_{v \in V} {\deg (v)} $。

**证明：**一个重要的观察是顶点的度就是入射其上的边的数目，并且每条边

都恰好入射到两个顶点。

**引理6.9：**如果一个平面图$G$有$m \geqslant 2$条边，$f$个face，则有$2m \geqslant 3f$，即$f \leqslant (2/3)m$。

**证明：**在平面图中，每个face都至少被三个边包围，每个边最多接触两个face，因此$3f$对每条边最多计算两次，同时$2m$对每个face最少计算三次。

**引理6.10：**每个平面图都有度为5或更小的顶点。

**证明：**考虑其反例图的每个顶点的度都是6或者更大，由引理6.9与欧拉示性数等式可知：
$$
2 = |V| - |E| + |F| \leqslant |V| - |E| + (2/3)|E|
$$
变换可得$|E| \leqslant 3|V| - 6$。现在我们使用引理6.8有$2|E| \leqslant 6|V| - 12$，由于$2|E|$是度的和，而且每个顶点的度都至少为6，则有下列成立：
$$
6|V| \leqslant 2|E| \leqslant 6|V| - 12
$$
显然矛盾。

在以上的证明中，我们还得到了一个额外的事实，完全图$K_5$不是一个平面图，这是因为我们证明了所有的平面图都满足$|E| \leqslant 3|V| - 6$，对于$K_5$来说$|E| = 10 > 15 - 6$。以上的方法不能证明$K_{3,3}$不是平面图，除非你做一点额外的工作（利用其没有长度为3的cycle的事实，cycle指的是从某个顶点出发回到此顶点的路径），之后可以利用引理6.10。特别的，由于$K_5$不是平面图，那么平面图不能拿$K_5$当作子图。

现在来证明五色定理。

**证明：**对$|V|$进行归纳。最基本的情况，对有5个或更少的顶点的图进行着色，每个顶点都是不同的颜色，显然满足。

现在顶点数大于等于6，通过引理6.10，我们知道$G$存在一个顶点的度最大为5。现在我们将这个顶点$v$移除组成的图还是平面图，继续移除，最终收缩到最基础的情况还是满足五色定理。所有我们想要扩展或修改着色以使得$v$获得更好的颜色。

设$v$的五个邻接点分别为${w_1},{w_2},{w_3},{w_4},{w_5}$。特别的，一定有一些${w_i},{w_j}$互不邻接，我们可以通过把它们合并，或者删除它们并插入一个新的顶点$x$使得其与所有在$N({w_i}) \cup N({w_j})$的顶点都邻接，这样形成了图$G'$。如果图$G'$是一个平面图的话，我们可以知道这些：图$G'$有$|V|-1$个顶点，根据归纳中的假设，我们可以对$G$中的大多数点着色成5种颜色之一（除了$w_i,w_j,和v$）。现在，使用$x$的颜色着色$w_i,w_j$，其不相邻，所以满足着色要求，这样就确保了$v$的邻接点只使用了五种颜色中的四种，那么$v$使用其邻接点未使用的颜色进行着色。

所以为什么图$G'$是平面图呢？为了论证这一点，我们必须证明移除$v$那么$w_i,w_j$会处于同一平面内，过程如图6.6。

![](\img\6.6.png)

关键在于$G$是平面图，而$v$又是所有$w$的邻接点。

当证明了图$G'$是平面图，那么整个也就证明完毕。

证明过程将图的五色定理转化成了递归算法，以下是代码部分，利用了Python的igraph库，首先先定义一个图：

![](\img\6.7.png)

找出两个不相邻的顶点：

![](\img\6.8.png)

基本的情况，当顶点数小于5时进行普通的着色，其他情况则形成前文所述$G'$，递归：

```python
def planar_five_color(graph):
    """ Color a planar graph with five colors.

    The output is produced by setting the 'color' attribute of graph.vs to be
    integers between 0 and 4.

    Arguments:
      graph: an igraph Graph object to color.

    Returns:
      the input graph with its 'color' attribute modified.
    """
    n = len(graph.vs)

    if n <= 5:
        graph.vs['color'] = colors[:n]
        return graph

    deg_at_most5_nodes = graph.vs.select(_degree_le=5)
    deg_at_most4_nodes = deg_at_most5_nodes.select(_degree_le=4)
    deg5_nodes = deg_at_most5_nodes.select(_degree_eq=5)

    if not deg5_nodes:
        raise ValueError("Input graph (or recursive subgraph) does not "
                         "have a degree 5 node. Input graph is not planar.")

    g_prime = graph.copy()
    # preserved when deleting vertices
    g_prime.vs['old_index'] = list(range(n))

    if len(deg_at_most4_nodes) > 0:
        v = deg_at_most4_nodes[0]
        g_prime.delete_vertices(v.index)
    else:
        v = deg5_nodes[0]
        neighbor_indices = [
            x['old_index'] for x in g_prime.vs[v.index].neighbors()
        ]

        g_prime.delete_vertices(v.index)
        neighbors_in_g_prime = g_prime.vs.select(old_index_in=neighbor_indices)

        result = find_two_nonadjacent(g_prime, neighbors_in_g_prime)
        if not result:
            raise NotPlanarError("Unable to find two nonadjacent vertices "
                                 "for recursive call. Input graph is not planar.")

        w1, w2 = result
        merge_two(g_prime, w1, w2)

    colored_g_prime = planar_five_color(g_prime)

    for w in colored_g_prime.vs:
        # subset selection handles the merged w1, w2 with one assignment
        graph.vs[w['old_index']]['color'] = w['color']

    neighbor_colors = set(w['color'] for w in v.neighbors())
    v['color'] = [j for j in colors if j not in neighbor_colors][0]
    return graph
```

代码部分详情见书上部分，这里只是简单摘录。

## 近似着色

之前提到过在最坏的情况下算法很难解决着色问题。为了解决这个问题，添加了平面这个约束。尽管实用的着色算法可能会使用行业标准的优化方案来解决着色问题，这这里尝试使用不同的方法来了解图形着色的原理。假设现在有一张图，可以使用三种颜色进行着色，然后我们试图找到一些我们所能找的更多颜色的着色方案（我们达不到最理想的情况，只能找一些相对好的着色方案）。

为三色图进行着色的第一种算法使用$4\sqrt n $种颜色着色，其中$n = |V|$。为了使数字具体化，我们假设三色图有1000个顶点，那么此算法将使用不超过127种颜色进行着色。听起来很烂，但算法非常简单，只要存在未经着色的顶点$v$其度至少为$\sqrt n $，那么就可以为其挑选三种新颜色。为$v$使用一种颜色，对$N(v)$使用另外两种颜色，之后移除这些顶点重复这个过程。如果没有度为$\sqrt n $的顶点了，那么就使用贪婪算法为剩下的顶点着色。

**定理6.11：**此算法使用最多$4\sqrt n $种颜色为任何三色图着色。

**证明：**假设$G$是三色图。第一种情况，有一个顶点的度大于等于$\sqrt n $，我们必须证明$N(v)$能被两种颜色着色。基于$G$是三色图的假设：在$G$的任何三色中，$v$使用了其邻接点未使用的颜色，只有两种颜色剩下。

如果没有度为$\sqrt n $的顶点，那么顶点的度小于等于$\sqrt n - 1$，结合命题6.4中我们可知贪心算法在该图上使用的颜色不超过$\sqrt n $。

现在我们必须计算总共使用了多少种颜色。第一种情况只会发生$\sqrt n $次，因为每次我们都会为$v$及其邻接点进行着色，我们会从$G$（$\sqrt n *\sqrt n  = n$）中移除那些$\sqrt n  + 1 \geqslant \sqrt n $的顶点。由于我们每一次都使用了3种新的颜色，所有我们一共使用了$3\sqrt n $种颜色。剩下的贪婪算法最多使用$\sqrt n $种颜色，所以一共最多使用$4\sqrt n $种颜色。

最近的突破已经能将颜色逼近到$n^{0.2}$，作为参考，1000个顶点的三色图可以有${n^{0.2}} \approx 4$种颜色，这是一个相当大的进步。注意，在本文中的可能或者不可能解决的问题，指的是是否存在一个算法，实现所需的最坏情况的保证。

