---
title: "\x96Programmer-and-Mathematics-三"
date: 2021-02-16 21:31:25
tags:
categories:
    - 文章
mathjax: true
---



# 变量名、重载和你的大脑

开发人员经常抱怨数学家们如何使用单字母的名称，如何重载和滥用符号，以及他们用来形容事物的单词本质上是无意义的，其唯一目的就是创造一个新单词。但是，开发人员却很少思考这背后的原因。

<!-- more -->

主要的原因是文化。在创造数学时，数学家有两个目标：发现关于数学事物的见解，然后以直观优雅的方式将真理传达给他人。尽管第二个目标暗示了数学家们确实有自己的风格，但使得证明或者数学理论更为优雅的首要目标还是希望其有助于理解。

在开发人员的眼中，好的软件是可维护的，可扩展的，模块化，可测试的，健壮的等等，但数学家们不会关心这些，因为数学不是生意。数学不是傻瓜式的证明，数学理论的成功并不依赖下一个傻瓜是否理解它。

数学不是被设计成可以扩展到数百万的普通人身上，而是要在抽象的基础上更进一步。从字面上来讲，纸上的标记促进了人类从勉强能做的算数到今天的机器学习算法和密码协议。到19世纪末才发明的集合使数学的抽象更进了一步。之后范畴论更是在抽象的层面上前进了一大步。

这样做的结果就是数学家们优化了他们的论述，能够最大限度提高效率和最小化认知负荷。

**变量名。**变量名旨在传递一些信息：类型、行为、起源等。每个数学家都知道$n$是自然数$f$是函数。数学家的每个领域都有他们的小约定来帮助节省时间，因为数学家们的交流通常是实时的（例如通过一块黑板）。当写下${f^*}$意味着是一种规范同构，而不必写成InducedHomomorphismF。

更深入的讲，通常更长的名字并不能更深入的阐明数学对象的性质。难道${f^*}$真的比InducedF所表示的含义更少吗？通常来说，越抽象，这些命名的约定越容易设计。$L$跟${\text{L}}$可以是不同的东西，前者代表对象，后者可能是一个函数，这是通过字体来区分。

归根到底，数学家对变量的命名是经过长期历史的沉淀的一种约定俗成。

**操作符重载。**重载的一个关键功能是突出了操作的预期性质。数学家们经常使用等式不等式以及类似$ \cong $这样的符号来代表一些我们不关心的差异。理想情况下，我们应该能从上下文来推断运算的含义。简而言之，就是我们的代码要写的规范。

**Sloppy notation。**总结下，有些符号例如求和符号虽然代码表示比较麻烦，但数学上非常简洁。

# 图

## 图的定义

图的定义从图示看更为的直观，如图6.1所示，所谓的图就是有一堆事物以及他们的连接关系所组成的。举个简单的例子，事物现在就是机场，如果机场之间有航线的话它们就被连接在一起。我们使用点和线来来描述这种结构，我们所关心的就是这种连接的结构。

![](/img/6.1.png)

现在我们使用建模的语言来描述这个定义。事物我们称作顶点（或者节点），连接关系称作边（或者线？）。为了简化定义，我们沿用第四章的定义，从集合中取出两个事物：
$$
\left( {\begin{array}{*{20}{c} }
  V \\ 
  2 
\end{array} } \right) = \{ \{ {v_1},{v_2}\} :{v_1} \in V,{v_2} \in V,{v_1} \ne {v_2}\} 
$$
**定义6.1：**图包含了节点$V$的集合，边的集合$E \subset \left( {\begin{array}{*{20}{c} }
  V \\ 
  2 
\end{array} } \right)$。整个的图可以被表示为$G = (V,E)$。

或者，可以将$E$视为任意集合，但存在这样一个函数$f:E \to \left( {\begin{array}{*{20} {c} }
  V \\ 
  2 
\end{array} } \right)$来描述这一条边连接着哪对点。一般来讲，数学家们会直接将边写成$e = (u,v)$。

以下是一些图的术语。我们一般将节点的数目称作$n=|V|$，边的数目称作$m=|E|$，对我们来说，这些值总是有限的。当两个节点$u,v \in V$被边$e=(u,v)$连接时，我们称这两个节点相邻接，$e$关联到$u$和$v$。$v$是$u$的邻接点，并将$N(u)$定义为$u$的邻接点的集合：
$$
N(u) = \{ v \in V:(u,v) \in E\} 
$$
邻接点（也就是入射边的数目）的数目称作顶点的度，将顶点映射到其度的函数称作deg：$V \to \mathbb{Z}$。为了更好的理解这些术语，可以看一下图6.2。

![](\img\m6.2.png)

其中$v$代表顶点，$e$代表边。$v_1$和$v_3$是邻接点，$e_2$关联$v_1$，$deg(v_2)=3$，$v_2$的所有邻接点也是$v_3$的邻接点。

本章中我们需要的另一个概念是连通图。首先，图中的“路径”指的是顶点与边交替的序列$({v_1},{e_1},{v_2},{e_2}, \ldots ,{v_t})$，其中每条边${e_i} = ({v_i},{v_{i + 1}})$都连接着相邻的顶点。从视觉上看，路径其实就是沿着边从一个顶点到另一个顶点遍历$G$的一种方式。在图6.2中，从$v_2$到$v_4$有许多不同的路径，有四条不重复任何顶点。很多作者都将路径限定为不经过重复的顶点，对于重复顶点的路径叫做途径和迹。

如果存在路径能够从任意一个顶点到达另一个顶点，这样的图称为连通，否则称为不连通。等效的，如果不能将$V$分成两个子集$X$和$Y$，且两者没有没有边连接，则这样的图是连通的。非连通的图是一些连通组件的并集，这里我们说的组件$v$指的是包含$v$的连通子图。一个顶点也可以是连通组件，这样的点称为孤立点。

## 图形着色

本章的研究内容是图$G=(V,E)$的上色问题，即对图中顶点颜色的分配使其满足某种属性。

**定义6.2：**$G=(V,E)$上的$k$色是这样一个函数：$\varphi :V \to \{ 1,2, \ldots ,k\} $，当$\varphi (u) \ne \varphi (v)$时我们称$e=(u,v)$着色正确，否则边着色不正确。如果每条边都着色正确则$\varphi $正确。如果图$G$有正确的$k$色，则着色完成。

现在在继续之前，写下较小的$n$和$k$作为例子。因为这是一个至关重要的定义，所以例子稍稍有些复杂。Petersen图如6.3所示，这种图在图论中具有十分重要的地位，因为它是最小的严格单元测试。错误的猜想往往会在Petersen图中失败，petersen图是三色的而不是两色的。

![](\img\m6.3.png)

**定义6.3：**图$G$的色数用$\chi (G)$来表示，是当$G$是$k$色时最小的那个$k$。

通过以上的解释，Petersen图的色数为3。

**定义6.4：**如果$G=(V,E)$是图，$d$是一个顶点$v \in V$的最大的度，则有$\chi (G) \leqslant d + 1$。

**证明：**这里使用贪婪策略来对图进行着色，以任意顺序选择$G$中顶点${v_1}, \ldots {v_n}$，对每一个$v_i$都挑选一个其邻接点未使用过的颜色$j$。在最坏的情况下，一个的度为$d$顶点$v$，其邻接点全部使用不同的颜色，则会使用$d+1$种颜色，否则其邻接点会重用某种颜色，所以在最坏的情况下颜色的数目是图中最大的度加上1。

关于思考图进行着色的另一个角度是分区。特别的，如果$G=(V,E)$是图，$\varphi $是着色函数，我们要找的是${\varphi ^{ - 1} }(j)$，即颜色为$j$的顶点的集合。很显然，符合条件的顶点之间没有边相接。而且，由于$\varphi $是一个函数，则${\varphi ^{ - 1} }(j)$将集合分成了不同的颜色类别，所有的边都连接着不同类别，如图6.5所示。

![](\img\m6.5.png)

这个角度是非常重要的，因为人们可以尝试从不正确的或未完成的着色开始完成正确的着色，并用其纠正不正确的着色。我们将在本章的实践（平面图着色）来进行实操，现在我们来思考图的着色为什么有用。

## 寄存器分配和难度

促进图着色发展的一种原因是可以将许多问题表达为“反协调问题”，即描述为当系统中代理人与其邻居没有相同行为时，将获得胜利。一个具体的例子就是射频，无线电发射塔选择某种要发射的频率，当附近的发射塔发射相同的频率时会相互干扰，因此，发射塔是顶点，附近的发射塔与其通过边相连接，这个问题中“颜色”就是频率。

